## Описание задачи

Нужно реализовать небольшой REST API-сервис для управления задачами пользователей (**Task Manager**).

### Основные сущности

1. **User**
   - Нужно использовать встроенную модель пользователя DjangoRestFramework.
   - Для упрощения авторизации пользователя нужно реализовать следующий алгоритм:
     - клиент передаёт `X-User-Id` в заголовке через ;
     - Мы считаем, что пользователь с таким `id` существует.

2. **Task**
   - `id`
   - `title` (string, обязательное)
   - `description` (string, опционально)
   - `status` (enum: `todo`, `in_progress`, `done`)
   - `due_date` (datetime, опционально)
   - `owner` (ссылка на модель User)
   - `created_at`, `updated_at`
   - `is_overdue` (boolean: default = False)

### Бизнес-правила

Обязательно реализовать следующие правила:

1. Пользователь может работать только со своими задачами:
   - нельзя просматривать/изменять/удалять задачи других пользователей;
   - `owner` задачи менять нельзя.

2. При изменении статуса задачи:
   - при установке `status="done"` у задачи должен быть задан `due_date`;
   - если правило нарушено — возвращать понятную ошибку валидации.

(Если хотите, можете добавить свои правила, но базовые два должны быть.)

### API-эндпоинты

Необходимо реализовать следующие операции:

1. Создание задачи (create).
2. Получение задачи по `id` (read by id).
3. Обновление задачи (update).
4. Удаление задачи (delete_.
5. Список задач текущего пользователя с возможностью:
   - фильтрации по `status`.
   - фильтрации по диапазону `due_date` - задается диапазон дат - "от" и "до".
   - пагинации - формат: page/size.

### Дополнительная логика

Нужно реализовать механизм, который помечает задачи как просроченные.

Вариант реализации:

- отдельный end-point, доступный только для админа (условно `/tasks/recalculate_overdue`).

Логика следующая:

- если `due_date < now()` и `status != "done"`, задача считается просроченной;
- просроченным задачам выставляется флаг `is_overdue: bool`.

Главное — вынести эту бизнес-логику из контроллера/вьюхи в отдельный слой (сервис/функцию), чтобы её можно было переиспользовать.

---

## Требования к реализации

### Технологии

- **Язык:** Python 3.10+
- **Фреймворк:** **Djangorestframework**.
- **База данных:** PostgreSQL.
- **Окружение:** Docker + docker-compose.
- **Локальное виртуальное окружение** UV

### Структура проекта

Мы намеренно **не навязываем** конкретный паттерн («чистая архитектура», «DDD», и т.п.), но ожидаем:

- разделения кода по слоям/модулям;
- отсутствие «больших файлов» с логикой всего приложения в одном месте;
- разумного разбиения на функции/классы.

В README, пожалуйста, кратко опишите свою структуру и основные решения.

### Docker и запуск

Обязательно:

- `docker-compose.yml`, поднимающий:
  - приложение;
  - PostgreSQL.
- Настройки через переменные окружения (`.env`):
  - параметры БД;
  - прочие секреты/ключи (если нужны).

Ожидаемый сценарий:

```bash
docker-compose up --build
```

и после этого сервис доступен на каком-то порту, указанном в README.

Команды для миграций вывести в отдельный sh-скрипт, который запускается из Docker (prestart.sh). Это также надо описать в README.

При первом запуске надо сформировать 5 тестовых пользователей - 2 - админа с паролем 123852 и 3 юзера, а также применить миграции к модели Task


### Тесты

Нужно добавить минимальный набор автотестов (стандартный тест-раннер фреймворка DRF):

- тест успешного создания задачи;
- тест нарушения бизнес-правила (например, нельзя установить status="done" без due_date);
- один тест на проверку доступа (нельзя удалить чужую задачу).
